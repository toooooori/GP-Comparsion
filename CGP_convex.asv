function [mse, nlpd, coverage, width, elapsedTime] = CGP_convex(t1_in, x_in, tstar_in, y_true)
% CGP_convex — Constrained Gaussian Process with convexity constraint f''(t) >= 0
%
% USAGE
%   [mse, nlpd, coverage, width, elapsedTime] = CGP_convex(t1, x, tstar, y_true)
%
% WHAT IT DOES
%   • Learns hyperparameters on f with GPML (SE + Noise).
%   • Adaptively selects constraint points t2 ⊂ tstar where P(f''(S) <= 0 | data)
%     is largest.
%   • Runs a main Gibbs sampler imposing f''(t2) >= 0 via a positive-part latent
%     variable scheme, then samples f(t*).
%   • Returns latent-space metrics on f(t*): MSE, NLPD, 95% CI coverage and width,
%     and the total elapsed time.
%
% DEPENDENCIES
%   GPML: gp, minimize, infExact, meanConst, covSEisoS, covNoise, covSum, likGauss
%   Utils: covGP2 (with 2nd-derivative blocks), gp_dist, jitterchol
%   Statistics & ML Toolbox: normcdf, norminv, normpdf, binornd, quantile
%
% NOTES
%   • No RNG seeding inside; call rng(...) outside if you need reproducibility.
%   • covGP2 must return (3-arg call):
%       K1 = cov(f(t1),     f(t1))     [n×n]
%       K2 = cov(f(t1),     f''(t2))   [n×m]
%       K3 = cov(f''(t2),   f''(t2))   [m×m]
%       KK2 = K2'                          .
%   • This implementation is 1D in t; extend gp_dist/covGP2 accordingly for >1D.

% ----------- I/O -----------
t1    = t1_in(:);
x     = x_in(:);
tstar = tstar_in(:);
y_true= y_true(:);
n     = numel(t1);
nstar = numel(tstar);

tAll = tic;

% ============================================================
% 1) Hyperparameter learning on f (covSum{SEisoS + Noise})
% ============================================================
meanfunc = {@meanConst}; hyp.mean = 0;
covfunc  = {'covSum',{'covSEisoS', 'covNoise'}};  hyp.cov = [0, 0, 0];
likfunc  = {@likGauss};  hyp.lik = log(1e-3); 

[hyp_sol, ~, ~] = minimize(hyp, @gp, -500, @infExact, meanfunc, covfunc, [], t1, x);

loghyper = hyp_sol.cov;
ell      = exp(hyp_sol.cov(1));
sigma_f  = exp(hyp_sol.cov(2));
mu       = hyp_sol.mean;

% Training covariance and decomposition
cov_X  = feval(covfunc{:}, loghyper, t1);           % n×n
L_covX = jitterchol(cov_X);

% ============================================================
% 2) Adaptive selection of convexity constraint points (on f'')
% ============================================================
set_num = 0;
[~, Ks2, Ks3, KKs2] = covGP2([log(ell);log(sigma_f)], t1, tstar);  % f vs f'', f'' vs f''
alpha_covX = L_covX'\(L_covX\(x - mu));
mu_dS      = KKs2 * alpha_covX;                         % mean of f''(tstar) | data
v_covX     = L_covX \ Ks2;                              % n×n \ n×n*'' → n×n*''
cov_dS     = Ks3 - v_covX' * v_covX;                    % Var of f''(tstar) | data
epsv       = 1e-12;
prob_y     = normcdf(zeros(size(tstar)), mu_dS, sqrt(max(diag(cov_dS), epsv)));

th_hd   = 1e-20;
t2      = [];
tstar_g = tstar;

while max(prob_y) > th_hd
    % ---- choose the next constraint location (your original tie-breaking) ----
    set_num = set_num + 1;
    temp = find(prob_y == max(prob_y)); lg = numel(temp);
    if lg ~= 1
        j = 1; temp_idx = 0;
        while j < lg
            a_mat = temp(j);
            for ii = j:lg
                if temp(ii) ~= (a_mat + ii - j)
                    temp_idx = ii - j;      
                    break;
                end
            end
            if temp_idx == 0, j = ii; else, temp_idx = ii - 1; break; end
        end
        if temp_idx ~= 0
            if mod(temp_idx,2)==0, temp_va = tstar(temp(temp_idx/2));
            else,                  temp_va = tstar(temp((temp_idx+1)/2));
            end
        else
            if mod(lg,2)==0, temp_va = tstar(temp(lg/2));
            else,            temp_va = tstar(temp((lg+1)/2));
            end
        end
    else
        temp_va = tstar(temp);
    end

    t2 = [t2; temp_va];

    % remove it from candidate grid
    tstar   = setdiff(tstar, t2);
    lg_star = numel(tstar);

    % ---- rebuild blocks for current t2 / remaining tstar ----
    [~, K2, K3, KK2]       = covGP2([log(ell);log(sigma_f)], t1, t2);     % f vs f'', f'' vs f''
    [~, Ks2, Ks3, KKs2]    = covGP2([log(ell);log(sigma_f)], t1, tstar);  % f vs f'', f'' vs f''

    % Cross block for f''(t2) vs f''(tstar) under SE kernel
    % r = (t2 - t*)/ell;  cov(f'', f'') = σ_f^2 * exp(-r^2/2) * (1/ell^4)*(r^4 - 6 r^2 + 3)
    tempK2 = gp_dist((t2.'/ell), (tstar.'/ell));   % size m×lg_star
    K_3    = sigma_f^2 * exp(-tempK2.^2/2) .* (1/ell^4) .* (tempK2.^4 - 6*tempK2.^2 + 3);

    % Joint blocks
    Sigma_11 = [cov_X, Ks2; KKs2, Ks3];
    Sigma_12 = [K2;    K_3'];
    Sigma_21 = [KK2,   K_3];
    Sigma_22 = K3;

    % Schur
    L_K3   = jitterchol(K3);
    v_K3   = L_K3 \ Sigma_21;
    mu_lam = [mu*ones(n,1); zeros(lg_star,1)];
    Lambda = Sigma_11 - v_K3' * v_K3;

    Lambda_11 = Lambda(1:n, 1:n);
    Lambda_12 = Lambda(1:n, n+1:n+lg_star);
    Lambda_21 = Lambda(n+1:n+lg_star, 1:n);
    Lambda_22 = Lambda(n+1:n+lg_star, n+1:n+lg_star);

    L_Lb      = jitterchol(Lambda_11);
    v_Lb      = L_Lb \ Lambda_12;
    Lambda_sig= Lambda_22 - v_Lb' * v_Lb;

    % Conditional of f'(t2) is replaced by conditional of f''(t2)
    mean_dX = (L_K3' \ (L_K3 \ KK2)).';        % n×m
    cov_dX  = cov_X - mean_dX * KK2;           % n×n
    L_dX    = jitterchol(cov_dX);

    % -------- Small Gibbs to update P(f''(tstar) <= 0 | ...) --------
    M    = 501;
    Zd   = zeros(set_num, M);      % latent f''(t2)
    Zd_p = zeros(set_num, M);      % positive part

    for k = 2:M
        mu_m    = zeros(set_num,1);
        nu_m    = zeros(set_num,1);
        theta_m = zeros(set_num,1);
        delta_m = zeros(set_num,1);

        for i = 1:set_num
            % prior conditional for f''(t2_i)
            temp_s     = K3(i,:);  temp_s(i) = [];
            temp_S     = K3;       temp_S(i,:)=[]; temp_S(:,i)=[];
            temp_a     = mean_dX(:, i);

            if set_num ~= 1
                if     i==1,          temp_A = mean_dX(:,2:set_num);
                elseif i==set_num,     temp_A = mean_dX(:,1:set_num-1);
                else,                  temp_A = [mean_dX(:,1:i-1), mean_dX(:,i+1:set_num)];
                end
            end

            if set_num ~= 1
                if     i>1 && i<set_num
                    temp_zp  = [Zd(1:i-1,k);  Zd(i+1:set_num,k-1)];
                    temp_zpp = [Zd_p(1:i-1,k);Zd_p(i+1:set_num,k-1)];
                elseif i==1
                    temp_zp  = Zd(2:set_num,  k-1);
                    temp_zpp = Zd_p(2:set_num,k-1);
                else
                    temp_zp  = Zd(1:set_num-1,  k);
                    temp_zpp = Zd_p(1:set_num-1, k);
                end
            end

            if set_num ~= 1
                tempS_chol  = jitterchol(temp_S);
                v_tempS     = tempS_chol \ (temp_s.');
                alpha_tempS = tempS_chol' \ (tempS_chol \ temp_zp);
                mu_m(i)     = temp_s * alpha_tempS;
                nu_m(i)     = K3(i,i) - v_tempS' * v_tempS;
                nu_sqrt     = sqrt(max(nu_m(i), 1e-12));
            else
                mu_m(i)     = 0;
                nu_m(i)     = max(K3, 1e-12);
                nu_sqrt     = sqrt(nu_m(i));
            end

            % posterior conditional with data
            if set_num ~= 1
                v_dX     = L_dX \ temp_a;
                temp_th1 = (x - mu) - temp_A * temp_zpp;
                alpha_dX = L_dX' \ (L_dX \ temp_th1);
                temp_th  = temp_a' * alpha_dX + mu_m(i) / nu_m(i);
                temp_dt1 = 1/nu_m(i) + v_dX' * v_dX;
                temp_dt  = 1 / max(temp_dt1, 1e-12);
                theta_m(i) = temp_dt * temp_th;
                delta_m(i) = sqrt(max(temp_dt, 1e-12));
            else
                v_dX     = L_dX \ mean_dX;
                alpha_dX = L_dX' \ (L_dX \ (x - mu));
                temp_th  = mean_dX' * alpha_dX + mu_m(i) / nu_m(i);
                temp_dt1 = 1/nu_m(i) + v_dX' * v_dX;
                temp_dt  = 1 / max(temp_dt1, 1e-12);
                theta_m(i) = temp_dt * temp_th;
                delta_m(i) = sqrt(max(temp_dt, 1e-12));
            end

            % Bernoulli mixture (robust)
            tiny    = 1e-15; eps0 = 0;
            temp_ks = max(min(normcdf(eps0, mu_m(i),   nu_sqrt),       1-tiny), tiny);
            temp_qx = max(min(1 - normcdf(eps0, theta_m(i), delta_m(i)),1-tiny), tiny);
            expo    = -mu_m(i)^2/(2*max(nu_m(i),1e-12)) + theta_m(i)^2/(2*max(temp_dt,1e-12));
            expo    = min(expo, 700);
            scale   = delta_m(i) / max(nu_sqrt,1e-12);        % (adaptive stage: delta/nu)
            temp_const = temp_qx * scale * exp(expo);
            den        = temp_ks + temp_const;
            q_const    = 0.5;
            if isfinite(temp_const) && isfinite(den) && den > 0
                q_const = max(min(temp_const/den, 1-1e-12), 1e-12);
            end

            b = binornd(1, q_const);
            if b == 0
                u = max(min(temp_ks * rand(1), 1 - tiny), tiny);
                Zd(i,k)   = norminv(u, mu_m(i), max(nu_sqrt, tiny));
                Zd_p(i,k) = 0;
            else
                u = 1 - (temp_qx - temp_qx * rand(1));
                u = max(min(u, 1 - tiny), tiny);
                Zd(i,k)   = norminv(u, theta_m(i), max(delta_m(i), tiny));
                Zd_p(i,k) = Zd(i,k);
            end
        end
    end

    if (nstar - set_num) > 0
        alpha_K3 = L_K3' \ (L_K3 \ mean(Zd_p(:,51:M),2)); 
        MU       = mu_lam + Sigma_12 * alpha_K3;

        mu_z   = MU(n+1:n+lg_star);
        mu_x   = MU(1:n);
        Z_mu   = mu_z + Lambda_21 * (L_Lb' \ (L_Lb \ (x - mu_x)));
        Z_sigma= Lambda_sig / (M - 50);

        prob_y = normcdf(zeros(lg_star,1), Z_mu, sqrt(max(diag(Z_sigma), epsv)));
    else
        t2 = tstar_g;
        break;
    end
end

% ============================================================
% 3) Main Gibbs (long run under f''(t2) >= 0)
% ============================================================
t2    = sort(t2);           % m×1
m     = numel(t2);
tstar = tstar_g;            % back to full grid

[~, K2, K3, KK2] = covGP2([log(ell);log(sigma_f)], t1, t2);      % f vs f'', f'' vs f''
L_covX   = jitterchol(cov_X);
alpha_covX = L_covX'\(L_covX\(x - mu));
L_K3     = jitterchol(K3);

mean_dX  = (L_K3' \ (L_K3 \ KK2)).';          % n×m
cov_dX   = cov_X - mean_dX * KK2;             % n×n
L_dX     = jitterchol(cov_dX);

[~, Ks2, Ks3, KKs2] = covGP2([log(ell);log(sigma_f)], tstar, t2); % f* vs f'', f'' vs f''
cov_Zxt = covSEisoS([log(ell);log(sigma_f)], t1,    tstar);       % n×n*
cov_Zts = covSEisoS([log(ell);log(sigma_f)], tstar);              % n*×n*

Sigma_11 = [cov_X,  cov_Zxt; 
            cov_Zxt', cov_Zts];
Sigma_12 = [K2;      Ks2];
Sigma_21 = [KK2,     KKs2];
Sigma_22 = K3;

v_K3     = L_K3 \ Sigma_21;
Lambda   = Sigma_11 - v_K3' * v_K3;

Lambda_11 = Lambda(1:n, 1:n);
Lambda_12 = Lambda(1:n, n+1:n+nstar);
Lambda_21 = Lambda(n+1:n+nstar, 1:n);
Lambda_22 = Lambda(n+1:n+nstar, n+1:n+nstar);

L_Lb      = jitterchol(Lambda_11);
v_Lb      = L_Lb \ Lambda_12;
Lambda_sig= Lambda_22 - v_Lb' * v_Lb;

% ---------------------- long Gibbs ----------------------
M      = 100000;
Z      = zeros(nstar, M);         % f(t*)
Zd     = zeros(m,     M);         % f''(t2)
Zd_p   = zeros(m,     M);         % positive part
jitter = 1e-6;

for k = 2:M
    mu_m    = zeros(m,1);
    nu_m    = zeros(m,1);
    theta_m = zeros(m,1);
    delta_m = zeros(m,1);

    for i = 1:m
        temp_s = K3(i,:); temp_s(i) = [];
        temp_S = K3;      temp_S(i,:) = []; temp_S(:,i) = [];

        temp_a = mean_dX(:, i);
        if     i==1, temp_A = mean_dX(:,2:m);
        elseif i==m, temp_A = mean_dX(:,1:m-1);
        else,        temp_A = [mean_dX(:,1:i-1), mean_dX(:,i+1:m)];
        end

        if i>1 && i<m
            temp_zp  = [Zd(1:i-1,k);  Zd(i+1:m,k-1)];
            temp_zpp = [Zd_p(1:i-1,k);Zd_p(i+1:m,k-1)];
        elseif i==1
            temp_zp  = Zd(2:m,  k-1);
            temp_zpp = Zd_p(2:m,k-1);
        else
            temp_zp  = Zd(1:m-1,  k);
            temp_zpp = Zd_p(1:m-1, k);
        end

        tempS_chol  = jitterchol(temp_S);
        v_tempS     = tempS_chol \ (temp_s.');
        alpha_tempS = tempS_chol' \ (tempS_chol \ temp_zp);
        mu_m(i)     = temp_s * alpha_tempS;
        nu_m(i)     = K3(i,i) - v_tempS' * v_tempS;
        nu_sqrt     = sqrt(max(nu_m(i), 1e-12));

        v_dX     = L_dX \ temp_a;  
        temp_th1 = (x - mu) - temp_A * temp_zpp;
        alpha_dX = L_dX' \ (L_dX \ temp_th1);
        temp_th  = temp_a' * alpha_dX + mu_m(i) / max(nu_m(i),1e-12);
        temp_dt1 = 1/max(nu_m(i),1e-12) + v_dX' * v_dX;
        temp_dt  = 1 / max(temp_dt1, 1e-12);
        theta_m(i)= temp_dt * temp_th;
        delta_m(i)= sqrt(max(temp_dt, 1e-12));

        % Bernoulli mixture (robust) — main Gibbs uses sqrt(delta/nu)
        tiny    = 1e-15; eps0 = 0;
        temp_ks = max(min(normcdf(eps0, mu_m(i),   nu_sqrt),       1-tiny), tiny);
        temp_qx = max(min(1 - normcdf(eps0, theta_m(i), delta_m(i)),1-tiny), tiny);
        expo    = -mu_m(i)^2/(2*max(nu_m(i),1e-12)) + theta_m(i)^2/(2*max(temp_dt,1e-12));
        expo    = min(expo, 700);
        scale   = sqrt(delta_m(i) / max(nu_sqrt,1e-12));
        temp_const = temp_qx * scale * exp(expo);
        den        = temp_ks + temp_const;
        q_const    = 0.5;
        if isfinite(temp_const) && isfinite(den) && den > 0
            q_const = max(min(temp_const/den, 1-1e-12), 1e-12);
        end

        b = binornd(1, q_const);
        if b == 0
            u = max(min(temp_ks * rand(1), 1 - tiny), tiny);
            Zd(i,k)   = norminv(u, mu_m(i), max(nu_sqrt, tiny));
            Zd_p(i,k) = 0;
        else
            u = 1 - (temp_qx - temp_qx * rand(1));
            u = max(min(u, 1 - tiny), tiny);
            Zd(i,k)   = norminv(u, theta_m(i), max(delta_m(i), tiny));
            Zd_p(i,k) = Zd(i,k);
        end
    end

    mu_lam   = mu * ones(n + nstar, 1);
    alpha_K3 = L_K3' \ (L_K3 \ Zd_p(:, k));
    MU       = mu_lam + Sigma_12 * alpha_K3;

    mu_z     = MU(n+1:n+nstar);
    mu_x     = MU(1:n);
    Z_mu     = mu_z + Lambda_21 * (L_Lb' \ (L_Lb \ (x - mu_x)));
    Z_sigma  = Lambda_sig;

    Z(:,k)   = Z_mu + chol(Z_sigma + jitter*eye(nstar))' * randn(nstar,1);
end

% ============================================================
% 4) Summaries & metrics (latent space)
% ============================================================
Zval = Z(:, 50001:100000);
Ef   = median(Zval, 2);
Varf = var(Zval, 0, 2);

ci    = quantile(Zval', [0.025, 0.975]);
ci_lo = ci(1,:)';
ci_hi = ci(2,:)';

epsv      = 1e-12;
mse       = mean( (Ef - y_true).^2 );
nlpd      = -mean( log( max(realmin, normpdf(y_true, Ef, sqrt(max(Varf,epsv)))) ) );
coverage  = mean( (y_true >= ci_lo) & (y_true <= ci_hi) );
width     = mean( ci_hi - ci_lo );

elapsedTime = toc(tAll);

% (Optional) quick plot (comment out in batch runs)
figure; plot(tstar_in, Ef, '.b', 'MarkerSize', 17); hold on;
plot(tstar_in, y_true, '.r', 'MarkerSize', 17);
plot(tstar_in, ci_lo, '-.b', 'LineWidth', 1);
plot(tstar_in, ci_hi, '-.b', 'LineWidth', 1);
legend('Posterior Mean','True f','Lower 95%','Upper 95%','Location','Best');
grid on; hold off;

end
